package it.at7.gemini.api.openapi;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import it.at7.gemini.api.ApiUtility;
import it.at7.gemini.core.Module;
import it.at7.gemini.exceptions.GeminiRuntimeException;
import it.at7.gemini.schema.Entity;
import it.at7.gemini.schema.EntityField;
import org.jetbrains.annotations.NotNull;

import java.util.*;
import java.util.stream.Collectors;

import static it.at7.gemini.api.openapi.OpenAPIBuilder.SchemaType.*;
import static it.at7.gemini.core.RecordConverters.GEMINI_UUID_FIELD;

public class OpenAPIBuilder {
    public static String OPENAPI_VERSION = "3.0.2";
    public static String INFO_TITLE = "Gemini";

    private final List<Tag> tags = new ArrayList<>();
    private final List<Server> servers = new ArrayList<>();
    private final Map<String, Path> pathsByName = new LinkedHashMap<>();
    private final Map<String, Object> components = new LinkedHashMap<>();

    private final Map<String, String> UNAUTHORIZED_REF = Map.of("$ref", "#/components/responses/Unauthorized");
    private final Map<String, String> DEFAULTERR_REF = Map.of("$ref", "#/components/responses/DefaultError");

    public OpenAPIBuilder() {
        initComponents();
    }

    private void initComponents() {
        addServer("/", "Root Server");
        components.put("responses", initResponseComponent());
        components.put("schemas", initSchemasComponent());
        components.put("parameters", initParametersComponent());
    }

    private Object initSchemasComponent() {
        return new LinkedHashMap<String, Schema>();
    }

    private Map<String, Response> initResponseComponent() {
        Map<String, Response> responses = new LinkedHashMap<>();
        responses.put("Unauthorized", makeUnauthorizedResponse());
        responses.put("DefaultError", makeDefaultResponse());
        return responses;
    }

    private Object initParametersComponent() {

        LinkedHashMap<String, Parameter> parameters = new LinkedHashMap<>();

        // UUID parameter
        Parameter uuid = new Parameter();
        uuid.name = "uuid";
        uuid.in = "path";
        uuid.required = true;
        uuid.description = "UUID generated by POST request";
        SchemaProperty uuidSchemaProp = new SchemaProperty();
        uuidSchemaProp.type = "string";
        uuidSchemaProp.format = "uuid";
        uuid.schema = uuidSchemaProp;
        parameters.put("uuid", uuid);

        // Gemini Header Parameter
        Parameter geminiHeader = new Parameter();
        geminiHeader.name = "Gemini";
        geminiHeader.in = "header";
        geminiHeader.required = false;
        geminiHeader.description = "Optional Header to enable Gemini Request/Response feature: \n * `gemini.api` - to enable Meta Data Response ";
        SchemaProperty gemHeaderSchemaProp = new SchemaProperty();
        gemHeaderSchemaProp.type = "string";
        gemHeaderSchemaProp._enum = List.of("gemini.api");
        geminiHeader.schema = gemHeaderSchemaProp;
        parameters.put("GeminiHeader", geminiHeader);

        return parameters;
    }

    private Response makeUnauthorizedResponse() {
        Response response = new Response();
        response.description = "Unauthorized";
        return response;
    }

    private Response makeDefaultResponse() {
        Response response = new Response();
        response.description = "Unexpected error";
        return response;
    }

    public String toJsonString() {
        ObjectMapper objectMapper = new ObjectMapper();
        HashMap<String, Object> rootJson = new LinkedHashMap<>();
        rootJson.put("openapi", OPENAPI_VERSION);
        rootJson.put("info", makeInfo());
        rootJson.put("servers", servers);
        rootJson.put("paths", pathsByName);
        rootJson.put("tags", tags);
        rootJson.put("components", components);
        try {
            objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            return objectMapper.writeValueAsString(rootJson);
        } catch (JsonProcessingException e) {
            throw new GeminiRuntimeException("Unable to serialize JSON");
        }
    }

    private Map<String, Object> makeInfo() {
        HashMap<String, Object> infoJson = new HashMap<>();
        infoJson.put("title", INFO_TITLE);
        infoJson.put("version", "1");
        return infoJson;
    }

    public void addModulesToTags(List<Module> orderedModules) {
        for (Module module : orderedModules) {
            tags.add(Tag.from(module.getName(), String.format("Section for all Entities of Module %s", module.getName())));
        }
    }

    public void handleEntity(Entity entity) {
        // Embedable entities are not exposed and don't need path
        if (!entity.isEmbedable()) {
            String entityName = entity.getName();
            String entityPathName = entityName.toLowerCase();
            tags.add(Tag.from(entityName, String.format("Section for entity %s", entityName)));

            // GET and POST on /entityname
            Path rootEntityPath = new Path();
            rootEntityPath.summary = String.format("%s resource route", entityName);
            rootEntityPath.get = getEntityListMethod(entity);
            rootEntityPath.post = postNewEntityMethod(entity);
            rootEntityPath.parameters = List.of(Map.of("$ref", "#/components/parameters/GeminiHeader"));
            this.pathsByName.put("/" + entityPathName, rootEntityPath);


            // GET / PUT and DELETE on /entityname/{uuid} -- always available
            Path uuidEntityPath = new Path();
            uuidEntityPath.summary = String.format("%s resource by UUID root", entityName);
            uuidEntityPath.get = getEntityUUIDandLKMethod(entity, "Get the %s resource by its uuid");
            uuidEntityPath.put = putEntityUUIDandLKMethod(entity, "Update any %s resource by its uuid");
            uuidEntityPath.delete = deleteEntityUUIDandLKMethod(entity, "Delete any %s resource by its uuid");
            uuidEntityPath.parameters = List.of(
                    Map.of("$ref", "#/components/parameters/uuid"),
                    Map.of("$ref", "#/components/parameters/GeminiHeader"));
            this.pathsByName.put("/" + entityPathName + "/{uuid}", uuidEntityPath);

            Entity.LogicalKey logicalKey = entity.getLogicalKey();
            // NOT Embedable with a LK can be used as reference
            if (!logicalKey.isEmpty()) {
                String lkPathString = entity.getLogicalKey().getLogicalKeyList().stream().map(e -> "{" + e.getName().toLowerCase() + "}").collect(Collectors.joining("/"));
                Path lkPath = new Path();
                lkPath.summary = String.format("%s resource by Entity Logical Key", entityName);
                lkPath.parameters = entity.getLogicalKey().getLogicalKeyList().stream().map(lk -> {
                    Parameter lkP = new Parameter();
                    lkP.in = "path";
                    lkP.required = true;
                    lkP.name = lk.getName().toLowerCase();
                    lkP.schema = new SchemaProperty();
                    fromFieldToProperty(lk, lkP.schema);
                    return lkP;
                }).collect(Collectors.toList());
                lkPath.parameters.add(Map.of("$ref", "#/components/parameters/GeminiHeader"));

                lkPath.get = getEntityUUIDandLKMethod(entity, "Get the %s resource by its Logical Key");
                lkPath.put = putEntityUUIDandLKMethod(entity, "Update any %s resource by its Logical Key");
                lkPath.delete = deleteEntityUUIDandLKMethod(entity, "Delete any %s resource by its Logical Key");

                this.pathsByName.put("/" + entityPathName + "/" + lkPathString, lkPath);
                addComponentSchema(entity, ENTITY_LK);
            }
        }

        // SCHEMAS
        addComponentSchema(entity, ENTITY);
        addComponentSchema(entity, ENTITY_WITH_META);
    }

    private Method getEntityListMethod(Entity entity) {
        Method method = new Method();
        method.summary = String.format("Get the list from %s resources", entity.getName());
        method.tags = getTagsForEntityMethod(entity);

        // 200 response has not components default
        Response response200 = new Response();
        response200.description = "Successful operation";
        response200.content = new LinkedHashMap<>();


        response200.content.put(String.format("application/json; %s=%s", ApiUtility.GEMINI_CONTENT_TYPE, ApiUtility.GEMINI_API_META_TYPE),
                Map.of("schema",
                        Map.of("type", "array",
                                "items",
                                Map.of("$ref", entityWithMetaSchemaName(entity)))));
        response200.content.put("application/json",
                Map.of("schema",
                        Map.of("type", "array",
                                "items",
                                Map.of("$ref", String.format("#/components/schemas/%s", entity.getName())))));
        method.responses.put("200", response200);

        method.responses.put("401", UNAUTHORIZED_REF);
        method.responses.put("default", DEFAULTERR_REF);

        return method;
    }

    private Method getEntityUUIDandLKMethod(Entity entity, String summary) {
        Method method = new Method();
        method.summary = String.format(summary, entity.getName());
        uuidLkCommonMethodDesc(entity, method, "Successful operation - return the wanted resource");
        return method;
    }

    private Method deleteEntityUUIDandLKMethod(Entity entity, String summary) {
        Method method = new Method();
        method.summary = String.format(summary, entity.getName());
        uuidLkCommonMethodDesc(entity, method, "Successfull DELETE operation - return the remove resource");
        return method;
    }

    private Method putEntityUUIDandLKMethod(Entity entity, String summary) {
        Method method = new Method();
        method.summary = String.format(summary, entity.getName());
        uuidLkCommonMethodDesc(entity, method, "Successfull UPDATE operation - return the modified resource");
        requestBodyEntitySchema(entity, method);
        return method;
    }
    
    private void requestBodyEntitySchema(Entity entity, Method method) {
        method.requestBody = new RequestBody();
        method.requestBody.required = true;
        method.requestBody.content = new LinkedHashMap<>();
        method.requestBody.content.put("application/json",
                Map.of("schema",
                        Map.of("$ref", String.format("#/components/schemas/%s", entity.getName()))));
    }

    @NotNull
    private void uuidLkCommonMethodDesc(Entity entity, Method method, String s) {
        method.tags = getTagsForEntityMethod(entity);

        Response response200 = new Response();
        response200.description = s;
        response200.content = new LinkedHashMap<>();
        response200JsonEntityRecord(entity, response200);
        method.responses.put("200", response200);
        method.responses.put("401", UNAUTHORIZED_REF);
        method.responses.put("default", DEFAULTERR_REF);
    }

    @NotNull
    private void response200JsonEntityRecord(Entity entity, Response response) {
        /*  with one of
            response.content.put("application/json",
                Map.of("schema",
                        Map.of("oneOf", List.of(
                                Map.of("type", "array",
                                        "items",
                                        Map.of("$ref", String.format("#/components/schemas/%s", entity.getName()))),
                                Map.of("$ref", String.format("#/components/schemas/%s", entityWithMetaSchemaName(entity)))
                                )
                        )
                )); */

        response.content.put(String.format("application/json; %s=%s", ApiUtility.GEMINI_CONTENT_TYPE, ApiUtility.GEMINI_API_META_TYPE),
                Map.of("schema",
                        Map.of("$ref", String.format("#/components/schemas/%s", entityWithMetaSchemaName(entity)))));

        response.content.put("application/json",
                Map.of("schema",
                        Map.of("$ref", String.format("#/components/schemas/%s", entity.getName()))));
    }

    private Method postNewEntityMethod(Entity entity) {
        Method method = new Method();
        method.summary = String.format("Create a new %s resource", entity.getName());
        method.tags = getTagsForEntityMethod(entity);
        requestBodyEntitySchema(entity, method);
        // 200 response has not components default
        Response response200 = new Response();
        response200.description = "Resource created";
        response200.content = new LinkedHashMap<>();
        response200JsonEntityRecord(entity, response200);
        method.responses.put("200", response200);
        method.responses.put("401", UNAUTHORIZED_REF);
        method.responses.put("default", DEFAULTERR_REF);
        return method;
    }

    @NotNull
    private List<String> getTagsForEntityMethod(Entity entity) {
        return List.of(entity.getModule().getName(), entity.getName());
    }

    public void addServer(String url, String description) {
        this.servers.add(Server.from(url, description));
    }


    private void addComponentSchema(Entity entity, SchemaType schemaType) {
        Map<String, Schema> schemas = (Map<String, Schema>) this.components.get("schemas");

        if (schemaType.equals(ENTITY)) {
            Schema entitySchema = createSchemaFor(entity.getDataEntityFields());
            schemas.put(entity.getName(), entitySchema);
        }
        if (schemaType.equals(ENTITY_LK)) {
            Schema entitySchema = createSchemaFor(entity.getLogicalKey().getLogicalKeySet());
            schemas.put(entityLkSchemaName(entity), entitySchema);
        }
        if (!entity.isEmbedable()) {
            if (schemaType.equals(ENTITY_WITH_META)) {
                Schema rootSchema = new Schema();
                rootSchema.type = "object";
                rootSchema.properties = new LinkedHashMap<>();
                Schema metaSchema = createSchemaFor(entity.getMetaEntityFields());

                SchemaProperty uuidProperty = new SchemaProperty();
                uuidProperty.type = "string";
                uuidProperty.format = "uuid";
                metaSchema.properties.put(GEMINI_UUID_FIELD, uuidProperty);

                rootSchema.properties.put("meta", metaSchema);
                Schema dataSchema = createSchemaFor(entity.getDataEntityFields());
                rootSchema.properties.put("data", dataSchema);
                rootSchema.required = List.of("meta", "data");
                schemas.put(entityWithMetaSchemaName(entity), rootSchema);
            }
        }
    }

    private Schema createSchemaFor(Set<EntityField> fields) {
        Schema schema = new Schema();
        schema.type = "object";
        schema.properties = new LinkedHashMap<>();
        List<String> requiredFields = new ArrayList<>();
        for (EntityField field : fields) {
            if (field.isLogicalKey())
                requiredFields.add(field.getName().toLowerCase());
            SchemaProperty schemaProperty = new SchemaProperty();
            String name = field.getName().toLowerCase();
            fromFieldToProperty(field, schemaProperty);
            schema.properties.put(name, schemaProperty);
        }
        if (!requiredFields.isEmpty()) {
            schema.required = requiredFields;
        }
        return schema;
    }

    private void fromFieldToProperty(EntityField field, SchemaProperty schemaProperty) {
        switch (field.getType()) {
            case TEXT:
                schemaProperty.type = "string";
                break;
            case NUMBER:
                schemaProperty.type = "number";
                break;
            case LONG:
                schemaProperty.type = "integer";
                schemaProperty.format = "int64";
                break;
            case DOUBLE:
                schemaProperty.type = "number";
                schemaProperty.format = "double";
                break;
            case BOOL:
                schemaProperty.type = "boolean";
                break;
            case TIME:
                schemaProperty.type = "string";
                schemaProperty.format = "time";
                break;
            case DATE:
                schemaProperty.type = "string";
                schemaProperty.format = "date";
                break;
            case DATETIME:
                schemaProperty.type = "string";
                schemaProperty.format = "date-time";
                break;
            case PASSWORD:
                schemaProperty.type = "string";
                schemaProperty.format = "password";
                break;
            case ENTITY_REF:
                schemaProperty.type = "object";
                schemaProperty.$ref = String.format("#/components/schemas/%s", entityLkSchemaName(field.getEntityRef()));
                break;
            case ENTITY_EMBEDED:
                schemaProperty.type = "object";
                schemaProperty.$ref = String.format("#/components/schemas/%s", field.getEntityRef().getName());
                break;
            case GENERIC_ENTITY_REF:
                // TODO
                break;
            case TEXT_ARRAY:
                schemaProperty.type = "array";
                schemaProperty.items = new SchemaProperty();
                schemaProperty.items.type = "string";
                break;
            case ENTITY_REF_ARRAY:
                schemaProperty.type = "array";
                schemaProperty.items = new SchemaProperty();
                schemaProperty.items.type = "object";
                break;
            case RECORD:
                // TODO
                break;
        }
    }


    private String entityLkSchemaName(Entity entity) {
        return entity.getName() + "_LK";
    }

    private String entityWithMetaSchemaName(Entity entity) {
        return entity.getName() + "_META";
    }

    static class Tag {

        public String name;
        public String description;

        private Tag(String name, String description) {
            this.name = name;
            this.description = description;
        }

        public static Tag from(String name, String description) {
            return new Tag(name, description);
        }
    }

    static class Path {
        public String summary;
        public String description;
        public List<Object> parameters;
        public Method get;
        public Method put;
        public Method post;
        public Method delete;
    }

    static class Method {
        public String summary;
        public List<String> tags;
        public RequestBody requestBody;
        public Map<String, Object> responses = new LinkedHashMap<>();
        public List<Object> parameters;
    }

    static class RequestBody {
        public String description;
        public boolean required;
        public Map<String, Object> content;
    }

    static class Response {
        public String description;
        public Map<String, Object> content;
    }

    static class Server {
        public String url;
        public String description;

        private Server(String url, String description) {
            this.url = url;
            this.description = description;
        }

        public static Server from(String url, String description) {
            return new Server(url, description);
        }
    }

    static class Schema {
        public String type;
        public Map<String, Object> properties;
        public List<String> required;
    }

    static class SchemaProperty {
        public String type;
        public String format;
        public SchemaProperty items;
        public String $ref;
        @JsonProperty("enum")
        public List<Object> _enum;
    }

    static class Parameter {
        public String name;
        public String in;
        public String description;
        public boolean required;
        public SchemaProperty schema;
    }

    enum SchemaType {
        ENTITY,
        ENTITY_WITH_META,
        ENTITY_LK
    }
}
